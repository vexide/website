---
title: vexide 0.8.0 Migration Guide
description: Migrate to the new vexide 0.8.0 runtime.
tags: ["writeups"]
author: lewisfm
date: 2025-09-04
---

vexide v0.8 is a new version of the runtime including improvements such as: support for the Rust Standard Library, new async runtime APIs, support for encoders with custom resolutions, the option to use the official VEX SDK, and various bug fixes. While we have aimed to minimize breaking changes, you will need to update your existing projects to make them compatible with this new release.

# Automatic Upgrade Tool

If you'd like to upgrade a project from v0.7 to v0.8, you can use our automatic upgrade tool to do much of the hard part for you:

```sh
cargo v5 upgrade
```

This will handle updating vexide, enabling the Rust Standard Library, and updating your project's Cargo configuration. However, it won't handle any changes to vexide's API, so if you encounter any build errors after the update, consult the [API Changes](#api-changes) section.

You'll need to have the latest version of cargo-v5 installed to use this command, so make sure to update it beforehand. **We also strongly suggest testing the upgrade on a separate branch**, then merging it once you've reviewed the changes to your code and verified that they work.

Even if you run the upgrade tool with no complications, we still recommend reading through all of the [Breaking Changes](#breaking-changes-guide) included in v0.8 to get a good idea of what's changed and make sure the upgrade tool didn't miss anything.

# Manual Upgrade Guide

Here's a comprehensive guide on upgrading to vexide v0.8 from v0.7. Apart from the [API Changes](#api-changes), most of these differences can be handled by our [Automatic Upgrade Tool](#automatic-upgrade-tool).

## Update vexide

To use vexide v0.8, you'll need to update it in your dependencies table:

```toml title="Cargo.toml"
# @fold start
[package]
name = "my-vexide-project"
version = "0.1.0"
edition = "2024"

[package.metadata.v5]
upload-strategy = "differential"
slot = 1
icon = "cool-x"
compress = true

# @fold end
[dependencies]
# @diff -
#         (   )
vexide = "0.7.0"
# @diff +
#         (           )
vexide = "0.8.0-alpha.1"
```

## Enable Standard Library Support

In vexide v0.8, projects must use Rust's new builtin support for VEX V5 devices, which means you may now use the comprehensive [Rust&nbsp;Standard&nbsp;Library][std]&nbsp;(`std`) in your vexide projects!

[std]: https://docs.rs/std

Delete the old `armv7a-vex-v5.json` target file:

```jsonc title="armv7a-vex-v5.json"
// @diff - start
{
    "cpu": "cortex-a9",
    "arch": "arm",
    "abi": "eabihf",
    // ...etc...
}
// @diff - end
```

Update `.cargo/config.toml` to use Rust's builtin VEX V5 support and enable the standard library:

```toml title=".cargo/config.toml"
[build]
# @diff +
target = "armv7a-vex-v5"
# @diff -
#         ()             (   )
target = "./armv7a-vex-v5.json"

[unstable]
# @diff +
#           (  )
build-std = true
# @diff -
#           (                                    )
build-std = ["core", "compiler_builtins", "alloc"]
# @diff -
build-std-features = ["compiler-builtins-mem"]
```

Update your project's source code to allow importing from the standard library:

```rs title="src/main.rs"
// @diff -
#![no_main]
// @diff -
#![no_std]

// @diff -
extern crate alloc;

use vexide::prelude::*;

#[vexide::main]
async fn main(peripherals: Peripherals) {
    println!("Hello, world!");
}
```

## Enable vexide's Custom Memory Layout

In order to support features like differential uploading and async task-locals, vexide v0.8 requires projects to enable its custom memory layout in the Cargo config file:

```toml title=".config/cargo.toml"
[build]
target = "armv7a-vex-v5"
# @diff +
rustflags = ["-Tvexide.ld"]

[unstable]
build-std = true
```

## Configure the VEX SDK (Advanced)

Traditionally, vexide programs have used the runtime's own open-source implementation of the VEX V5 platform SDK, a low-level library used to access devices like motors, sensors, and serial ports.

However, in v0.8, *advanced users* may now opt-in to using an alternative version of the SDK, such as the official one distributed by VEX Robotics for VEXcode or even one specifically made for your project. This option is intended to make it easier to use vexide in projects with unique licensing requirements.

### Keeping the existing behavior

**Most users will not need to change anything to keep the existing behavior**, but if you've previously disabled vexide's default features you may need to enable the `vex-sdk-jumptable` feature:

```toml title="Cargo.toml"
# @fold start
[package]
name = "my-vexide-project"
version = "0.1.0"
edition = "2024"

[package.metadata.v5]
upload-strategy = "differential"
slot = 1
icon = "cool-x"
compress = true

# @fold end
[dependencies.vexide]
version = "0.8.0-alpha.1"
default-features = false
features = [
    "core",
    "startup",
    "allocator",
# @diff +
    "vex-sdk-jumptable",
]
```

### Using the VEXcode SDK

> [!WARNING]
> Before using the VEXcode SDK, make sure you've reviewed its **nonfree licensing terms** to ensure
> your project is compliant. Notably, VEX prohibits redistribution and decompilation of their SDK.

If you've decided that your project's needs require it to use VEX's own implementation of
the platform SDK, disable vexide's default features to out-out of using the default open-source SDK and enable the `vex-sdk-build` feature.

```toml title="Cargo.toml"
# @fold start
[package]
name = "my-vexide-project"
version = "0.1.0"
edition = "2024"

[package.metadata.v5]
upload-strategy = "differential"
slot = 1
icon = "cool-x"
compress = true

# @fold end
[dependencies.vexide]
version = "0.8.0-alpha.1"
# @diff + start
default-features = false
features = [
    "async",
    "devices",
    "core",
    "startup",
    "macro",
    "backtraces",
    "allocator",
    "panic-hook",
#   (                  )
    "vex-sdk-build",
]
# @diff + end
```

Upon building your project, vexide will download the VEXcode SDK to your project's `target` folder and automatically use it.

# API Changes

## Position Arithmetic

`Position` structs are now internally represented as floating point values.

```rs
let pos1 = Position::from_degrees(90.0);

// @diff - start
let pos2 = pos1 / 2;
let pos3 = pos1 * 2;
// @diff - end

// @diff + start
let pos2 = pos1 / 2.0;
let pos3 = pos1 * 2.0;
// @diff + end
```

## ADI Encoder Ticks

The `AdiEncoder` struct now requires you to specify a custom encoder Ticks Per Revolution value. To keep the old behavior, use `AdiOpticalEncoder`.

```rs
// @diff -
let encoder = AdiEncoder::new(peripherals.adi_a, peripherals.adi_b);

// @diff +
let encoder = AdiOpticalEncoder::new(peripherals.adi_a, peripherals.adi_b);
```

## Gyroscope Yaw Format

The `AdiGyroscope` struct now returns its yaw in degrees.

```rs
let gyro = AdiGyroscope::new(peripherals.adi_a);

// @diff -
let yaw_pos = gyro.yaw()?;
// @diff +
let yaw_pos = Position::from_degrees(gyro.yaw()?);
```

## Rotation Sensor Calculation Interval

The function for changing the calculation interval of a `RotationSensor` was renamed from `set_computation_interval` to `set_data_interval`.

```rs
let mut sensor = RotationSensor::new(peripherals.port_1, Direction::Forward);
let interval = Duration::from_millis(10);

// @diff -
sensor.set_computation_interval(interval)?;
// @diff +
sensor.set_data_interval(interval)?;
```

## Buffer stride removed

The `Display::draw_buffer` function no longer takes a stride argument.

```rs
let buf: &[u32] = [
    0, 0, 0, 0, // row 1
    // ...etc...
];
let region = Rect::new([1, 1], [4, 4]);


// @diff -
let width = 1 + region.end.x - region.start.x;
// @diff -
//                             (     )
display.draw_buffer(region, buf, width);
// @diff +
display.draw_buffer(region, buf);
```

## Manual usage of startup function

> [!NOTE]
> This is an advanced feature and it is unlikely your project is affected. If you use the
> `#[vexide::main]` attribute, this change does not affect your project.

The `vexide::startup::startup()` function no longer handles printing vexide's banner message.

If you are manually calling `vexide::startup::startup()`, you will need to explicitly print vexide's banner to keep the previous behavior.

```rs
unsafe {
    // @diff -
    //                      (      )
    vexide::startup::startup::<true>();

    // @diff +
    vexide::startup::banner::print();
    // @diff +
    vexide::startup::startup();
}
```
